========================================
   STOCKROBO-US01 PHASE 2 BACKUP (LATEST UPDATED)
   Date: 2026-01-28 00:46:06
========================================

FILE: run_phase2_paper.py
from src.execution.order_manager import OrderManager
from src.risk.risk_manager import RiskManager

def main():
    print("==========================================")
    print("   StockRobo-US01: Phase 2 Execution Demo ")
    print("   (Paper Trading & Logic Test)           ")
    print("==========================================")
    
    # 1. Initialize Systems
    cash = 50_000
    risk_pct = 2.0
    
    order_mgr = OrderManager(cash_balance=cash)
    risk_mgr = RiskManager(portfolio_value=cash, risk_per_trade_pct=risk_pct)
    
    # 2. Simulate Signal Generation (From Scanner)
    # Scenario: We found 5 signals, but maybe we can't afford all, or need to pick best.
    raw_signals = [
        {'symbol': 'TSLA', 'strategy': 'FiboZone', 'entry': 420.0, 'stop': 380.0, 'win_rate': 87.5, 'change_pct': -5.5},
        {'symbol': 'NVDA', 'strategy': 'FiboZone', 'entry': 140.0, 'stop': 135.0, 'win_rate': 95.0, 'change_pct': -3.2},
        {'symbol': 'AAPL', 'strategy': 'CDCActionZone', 'entry': 230.0, 'stop': 220.0, 'win_rate': 60.0, 'change_pct': 0.5},
        {'symbol': 'GME', 'strategy': 'FiboZone', 'entry': 25.0,  'stop': 20.0,  'win_rate': 40.0, 'change_pct': -10.0}, # High risk
        {'symbol': 'MSFT', 'strategy': 'CDCActionZone', 'entry': 400.0, 'stop': 390.0, 'win_rate': 75.0, 'change_pct': 1.2}
    ]
    
    # 3. Prioritization Logic (Smart Selection)
    ranked_signals = order_mgr.prioritize_signals(raw_signals)
    
    # 4. Processing Best Signals
    orders_to_send = []
    
    print("\n[EXEC] Calculating Sizing & Orders for Top Picks...")
    for sig in ranked_signals:
        # Stop if we run out of simulated 'slots' or just execute top N
        # For now, process all valid ones.
        
        # A. Position Sizing
        sizing = risk_mgr.calculate_position_size(sig['entry'], sig['stop'])
        if sizing['shares'] == 0:
            print(f"  Skipping {sig['symbol']}: {sizing.get('reason', 'Zero shares')}")
            continue
            
        print(f"  {sig['symbol']}: Size {sizing['shares']} shares (Risk ${sizing['total_risk_dollars']:.0f})")
        
        # B. Create Order Ticket (with Market/Limit logic)
        order = order_mgr.create_order(sig, sizing)
        if order:
            orders_to_send.append(order)
            
    # 5. Execution (Paper Trade)
    order_mgr.execute_orders(orders_to_send)
    
    # 6. Reconciliation
    order_mgr.reconcile()

if __name__ == "__main__":
    main()


FILE: run_phase2_gh_action.py
import sys
import os
import json

# --- CRITICAL FIX: Force Add Paths ---
# 1. à¸«à¸²à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¹„à¸Ÿà¸¥à¹Œà¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
current_file_path = os.path.abspath(__file__)
current_dir = os.path.dirname(current_file_path)

# 2. à¹€à¸žà¸´à¹ˆà¸¡ path à¸‚à¸­à¸‡à¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œà¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
if current_dir not in sys.path:
    sys.path.append(current_dir)

# 3. à¸¥à¸­à¸‡à¸«à¸²à¹‚à¸Ÿà¸¥à¹€à¸”à¸­à¸£à¹Œ 'src' à¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆà¹„à¸«à¸™
# à¸–à¹‰à¸²à¹„à¸Ÿà¸¥à¹Œà¸™à¸µà¹‰à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ stockrobo-us01/run_...py à¹à¸•à¹ˆ src à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ stockrobo-us01/src
src_path = os.path.join(current_dir, 'src')

# à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹€à¸ˆà¸­ src à¹ƒà¸«à¹‰à¸¥à¸­à¸‡à¸–à¸­à¸¢à¸­à¸­à¸à¹„à¸› 1 à¸Šà¸±à¹‰à¸™ (à¹€à¸œà¸·à¹ˆà¸­à¹„à¸Ÿà¸¥à¹Œà¸­à¸¢à¸¹à¹ˆà¸¥à¸¶à¸)
if not os.path.exists(src_path):
    parent_dir = os.path.dirname(current_dir)
    if parent_dir not in sys.path:
        sys.path.append(parent_dir)
    src_path = os.path.join(parent_dir, 'src')

print(f"[DEBUG] Current Dir: {current_dir}")
print(f"[DEBUG] System Path: {sys.path}")
# -------------------------------------

try:
    from src.engine.scanner import MarketScanner
    from src.execution.order_manager import OrderManager
    from src.risk.risk_manager import RiskManager
    from src.notification.alert_engine import AlertEngine
except ImportError as e:
    print(f"CRITICAL IMPORT ERROR: {e}")
    print("Listing files in current directory:")
    print(os.listdir(current_dir))
    if os.path.exists(src_path):
         print(f"Listing files in src directory ({src_path}):")
         print(os.listdir(src_path))
    sys.exit(1)

def main():
    try:
        alert_system = AlertEngine()
    except:
        class MockAlert:
            def send_alert(self, *args): print(f"[MOCK ALERT] {args}")
        alert_system = MockAlert()

    print("--- [GH ACTION] StockRobo-US01 Phase 2 Execution ---")
    alert_system.send_alert("GH_ACTION", "Starting Scheduled Scan...", "INFO")
    
    try:
        # State File (Force Absolute Path)
        state_file_path = os.path.join(current_dir, "data", "portfolio_state.json")
        os.makedirs(os.path.dirname(state_file_path), exist_ok=True)
        
        order_manager = OrderManager(state_file=state_file_path)
        risk_manager = RiskManager(portfolio_value=50000.0, risk_per_trade_pct=2.0)
        scanner = MarketScanner()
        
        # Load watchlist (from file or use default)
        watchlist_path = os.path.join(current_dir, "data", "watchlist.json")
        
        if os.path.exists(watchlist_path):
            try:
                with open(watchlist_path, 'r') as f:
                    watchlist_data = json.load(f)
                    target_symbols = watchlist_data.get('watchlist', [])
                    print(f"[GH ACTION] Loaded watchlist from file: {len(target_symbols)} symbols")
                    print(f"[GH ACTION] Generated at: {watchlist_data.get('generated_at', 'Unknown')}")
            except Exception as e:
                print(f"[GH ACTION] Error loading watchlist: {e}")
                target_symbols = ['SPY', 'QQQ', 'NVDA', 'TSLA', 'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'AMD']
        else:
            print("[GH ACTION] No watchlist found. Using default symbols.")
            target_symbols = ['SPY', 'QQQ', 'NVDA', 'TSLA', 'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'AMD']
        
        print(f"[GH ACTION] Scanning {len(target_symbols)} symbols...")
        results = scanner.scan(target_symbols)
        
        signals = []
        for item in results.get('buy_signals', []):
            item['strategy'] = 'Scanner_CDC' 
            item['win_rate'] = 75.0 
            signals.append(item)
            
        print(f"[GH ACTION] Found {len(signals)} raw buy signals.")

        
        if signals:
            ranked_signals = order_manager.prioritize_signals(signals)
            
            order_manager.load_state() 
            temp_cash = order_manager.cash_balance
            final_orders = []
            
            for sig in ranked_signals:
                entry_price = sig['price']
                stop_price = entry_price * 0.95
                sizing = risk_manager.calculate_position_size(entry_price, stop_price)
                cost = sizing['shares'] * entry_price
                
                if cost > temp_cash:
                     sizing['shares'] = int(temp_cash // entry_price)
                     cost = sizing['shares'] * entry_price
                
                if sizing['shares'] > 0:
                    sig['entry'] = entry_price
                    order = order_manager.create_order(sig, sizing)
                    if order:
                        final_orders.append(order)
                        temp_cash -= cost 

            if final_orders:
                order_manager.execute_orders(final_orders)
                alert_system.send_alert("GH_ACTION", f"Successfully executed {len(final_orders)} orders.", "INFO")
            else:
                 print("[GH ACTION] No orders generated (Insufficient Cash).")
        else:
            print("[GH ACTION] No signals found.")

    except Exception as e:
        print(f"CRITICAL RUNTIME ERROR: {e}")
        alert_system.send_alert("GH_ACTION", f"Critical Error: {e}", "CRITICAL")
        sys.exit(1)

if __name__ == "__main__":
    main()

FILE: run_bot_loop.py
import time
import datetime
import schedule
import sys
import traceback
from src.engine.scanner import MarketScanner
from src.execution.order_manager import OrderManager
from src.risk.risk_manager import RiskManager
from src.notification.alert_engine import AlertEngine

class AutonomousBot:
    def __init__(self):
        self.alert_system = AlertEngine(log_file="logs/bot_activity.log")
        self.alert_system.send_alert("SYSTEM", "Initializing StockRobo-US01...", "INFO")
        
        try:
            self.scanner = MarketScanner()
            self.order_manager = OrderManager(cash_balance=50000.0) # Paper Portfolio
            self.risk_manager = RiskManager(portfolio_value=50000.0, risk_per_trade_pct=2.0)
            self.target_symbols = [
                'SPY', 'QQQ', 'NVDA', 'TSLA', 'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'AMD'
            ]
            self.is_running = True
            self.alert_system.send_alert("SYSTEM", "Initialization Complete.", "INFO")
        except Exception as e:
            self.alert_system.send_alert("CRITICAL", f"Initialization Failed: {e}", "CRITICAL")
            raise e

    def heartbeat(self):
        """Simple check to show bot is alive."""
        # Using a lower log level or just console for heartbeat to avoid flooding logs?
        # For now, let's keep it visible but maybe distinct.
        print(f"[{datetime.datetime.now().strftime('%H:%M:%S')}] [HEARTBEAT] System Operational.")

    def job_market_scan(self):
        """
        Main Routine: Scan -> Signal -> Size -> Execute
        """
        self.alert_system.send_alert("SCANNER", "Starting Scheduled Market Scan...", "INFO")
        
        try:
            # 1. Scan
            results = self.scanner.scan(self.target_symbols)
            
            # Combine signals (Buy + Sell if we were handling shorts/exits)
            # For this demo phase, let's focus on BUY signals from Scanner
            signals = []
            
            # Process Buy Signals
            for item in results.get('buy_signals', []):
                # Alert for each signal found
                self.alert_system.send_alert("SIGNAL", f"Found BUY signal: {item['symbol']} at {item['price']:.2f}", "INFO")
                
                # Enrich signal with Strategy Tag (Scanner mostly does CDC currently)
                item['strategy'] = 'Scanner_CDC' # Simplification
                # Mock win rate for simulation
                item['win_rate'] = 75.0 
                signals.append(item)
                
            # Process Heavy Drops (Alert Only for now)
            for item in results.get('heavy_drops', []):
                 self.alert_system.send_alert("WATCH", f"Heavy Drop Detected: {item['symbol']} ({item['change_pct']:.2f}%)", "WARNING")
                 # In real implementation, FiboStrategy would run here
                 pass

            if not signals:
                self.alert_system.send_alert("SCANNER", "No actionable signals found this cycle.", "INFO")
                return

            self.alert_system.send_alert("OPPORTUNITY", f"Found {len(signals)} potential candidates.", "INFO")
            
            # 2. Prioritize
            ranked_signals = self.order_manager.prioritize_signals(signals)
            
            # 3. Execution Loop
            orders_to_send = []
            for sig in ranked_signals:
                # Check Risk/Sizing
                # stop loss logic usually comes from strategy. 
                # For scanner results, we might assume a trailing stop or % stop
                # Let's mock a Stop Loss 5% below entry for scanner results
                entry_price = sig['price']
                stop_price = entry_price * 0.95
                
                sizing = self.risk_manager.calculate_position_size(entry_price, stop_price)
                if sizing['shares'] > 0:
                    sig['entry'] = entry_price # Normalize keys
                    
                    order = self.order_manager.create_order(sig, sizing)
                    if order:
                        orders_to_send.append(order)
                        self.alert_system.send_alert("ORDER_GEN", f"Generated Order for {sig['symbol']}: {sizing['shares']} shares", "INFO")
            
            # 4. Execute
            if orders_to_send:
                self.order_manager.execute_orders(orders_to_send)
                self.alert_system.send_alert("EXECUTION", f"Sent {len(orders_to_send)} orders to market.", "INFO")
            
            # 5. Reconcile
            self.order_manager.reconcile()

        except Exception as e:
            self.alert_system.send_alert("ERROR", f"Error during market scan loop: {e}", "ERROR")
            traceback.print_exc() 
            # We do NOT raise here, effectively keeping the loop alive despite a crash in this job.

    def start_loop(self):
        self.alert_system.send_alert("SYSTEM", "StockRobo-US01: Autonomous Loop STARTED", "INFO")
        self.alert_system.send_alert("SYSTEM", f"Monitoring {len(self.target_symbols)} Symbols", "INFO")
        
        # Schedule Jobs
        # In real world: Market hours check. Here: Run every 1 minute for DEMO.
        schedule.every(1).minutes.do(self.job_market_scan)
        schedule.every(30).seconds.do(self.heartbeat)
        
        # Initial Run immediately
        self.job_market_scan()
        
        try:
            while self.is_running:
                schedule.run_pending()
                time.sleep(1)
        except KeyboardInterrupt:
            self.alert_system.send_alert("SYSTEM", "Bot Stopped by User (KeyboardInterrupt).", "WARNING")
        except Exception as e:
            self.alert_system.send_alert("CRITICAL", f"Main Loop Crash: {e}", "CRITICAL")
            raise e

if __name__ == "__main__":
    bot = AutonomousBot()
    bot.start_loop()


FILE: src/execution/order_manager.py
from typing import List, Dict, Any, Optional
import time
import uuid
import json
import os

class OrderManager:
    """
    Simulates the Execution Engine for Phase 2.
    Handles Priority, Order Type Selection, and Reconciliation (Simulated).
    Supports Persistence for stateless environments (e.g., GitHub Actions).
    """
    
    def __init__(self, cash_balance: float = 50000.0, state_file: str = "data/portfolio_state.json"):
        self.state_file = state_file
        # Default starting values
        self.cash_balance = cash_balance
        self.orders = []
        self.portfolio: Dict[str, int] = {} # Symbol -> Quantity
        
        # Load previous state if available
        self.load_state()

    def load_state(self):
        """Load portfolio and orders from JSON file."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, 'r') as f:
                    data = json.load(f)
                    self.cash_balance = data.get('cash_balance', self.cash_balance)
                    self.portfolio = data.get('portfolio', {})
                    self.orders = data.get('orders', [])
                    print(f"[EXEC] Loaded persistence state from {self.state_file}")
                    print(f"       Cash: ${self.cash_balance:.2f} | Positions: {len(self.portfolio)}")
            except Exception as e:
                print(f"[EXEC] Error loading state: {e}")
        else:
            print("[EXEC] No saved state found. Starting fresh.")

    def save_state(self):
        """Save current portfolio and orders to JSON file."""
        data = {
            'timestamp': time.time(),
            'cash_balance': self.cash_balance,
            'portfolio': self.portfolio,
            'orders': self.orders[-50:] # Keep last 50 orders history
        }
        try:
            os.makedirs(os.path.dirname(self.state_file), exist_ok=True)
            with open(self.state_file, 'w') as f:
                json.dump(data, f, indent=4)
            print(f"[EXEC] State saved to {self.state_file}")
        except Exception as e:
            print(f"[EXEC] Error saving state: {e}")
        
    def prioritize_signals(self, signals: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Rank signals based on criteria:
        1. Backtest Win Rate (if available)
        2. Signal Strength (e.g., Fibo Deep Discount > Shallow Dip)
        3. Risk/Reward Ratio (implied)
        """
        print(f"\n[EXEC] Prioritizing {len(signals)} signals...")
        
        # Scoring Logic
        for sig in signals:
            score = 0
            
            # Criterion 1: Strategy Type Preference
            if sig['strategy'] == 'FiboZone':
                score += 50 # Base preference for Mean Reversion (Deep Value)
            elif sig['strategy'] == 'CDCActionZone':
                score += 30 # Trend Following
            
            # Criterion 2: Win Rate (Simulated data field)
            win_rate = sig.get('win_rate', 50.0)
            score += win_rate # e.g., +80 points for 80% win rate
            
            sig['priority_score'] = score
            
        # Sort by Score descending
        sorted_signals = sorted(signals, key=lambda x: x['priority_score'], reverse=True)
        
        for i, sig in enumerate(sorted_signals):
            print(f"  #{i+1}: {sig['symbol']} ({sig['strategy']}) - Score: {sig['priority_score']}")
            
        return sorted_signals

    def determine_order_type(self, symbol: str, price: float, current_volatility: float = 1.0) -> str:
        """
        Decide between Market vs Limit Order.
        Logic:
        - High Volatility -> Limit Order (to avoid slippage)
        - Low Volatility -> Market Order (speed)
        """
        # Threshold: If daily move > 2%, use LIMIT.
        if current_volatility > 2.0:
            return "LIMIT"
        else:
            return "MARKET"

    def create_order(self, signal: Dict[str, Any], position_size: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Generate an Order Ticket.
        """
        shares = position_size['shares']
        if shares <= 0:
            return None
            
        price = position_size['entry']
        # Simulating fetching recent volatility (change_pct) from signal
        volatility = signal.get('change_pct', 0.0)
        
        order_type = self.determine_order_type(signal['symbol'], price, abs(volatility))
        limit_price = price if order_type == 'LIMIT' else None
        
        order = {
            'order_id': str(uuid.uuid4())[:8],
            'symbol': signal['symbol'],
            'action': 'BUY',
            'quantity': shares,
            'order_type': order_type,
            'limit_price': limit_price, # Only for LIMIT
            'status': 'PENDING',
            'timestamp': time.time(),
            'notes': f"Strategy: {signal['strategy']} | Score: {signal.get('priority_score')}"
        }
        
        return order

    def execute_orders(self, orders: List[Dict[str, Any]]):
        """
        Process the orders (Paper Trade Execution).
        """
        print(f"\n[EXEC] Processing {len(orders)} Orders...")
        
        for order in orders:
            cost = order['quantity'] * (order['limit_price'] if order['limit_price'] else 0) # Estimates
            
            # 1. Validation (Liquidity Check / Cash Check)
            # (In simulation we assume we calculated size correctly already)
            
            # 2. Execution
            if order['status'] == 'PENDING':
                print(f"  >>> Sending {order['order_type']} ORDER: Buy {order['quantity']} {order['symbol']} @ {order['limit_price'] if order['limit_price'] else 'Market'} ...")
                time.sleep(0.5) # Simulate network
                
                # 3. Fill Simulation
                order['status'] = 'FILLED'
                order['filled_price'] = order['limit_price'] if order['limit_price'] else 100.00 # Mock fill
                
                print(f"  [FILLED]: {order['symbol']} (ID: {order['order_id']})")
                self.orders.append(order)
                
                # Update Portfolio
                qty = self.portfolio.get(order['symbol'], 0)
                self.portfolio[order['symbol']] = qty + order['quantity']
                
                # Update Cash (Simulated)
                self.cash_balance -= cost
                print(f"  [CASH] Deducted ${cost:.2f}. New Balance: ${self.cash_balance:.2f}")

        # Save State after batch execution
        self.save_state()

    def reconcile(self):
        """
        Verify internal state matches 'Broker'. 
        In simulation, we just print the portfolio.
        """
        print("\n[EXEC] --- Reconciliation Check ---")
        print(f"Internal Portfolio Record: {self.portfolio}")
        print("Broker Status: MATCHED (Simulated)")
        # In real world, we would call broker_api.get_positions() and compare.



FILE: src/notification/alert_engine.py
import os
import datetime
import requests
import traceback
from typing import Optional
import src.config as config

class AlertEngine:
    """
    Handles system-wide notifications and logging.
    Supports Console output, File logging, and Telegram.
    """
    def __init__(self, log_file: str = "system_alerts.log"):
        self.log_file = log_file
        self.ensure_log_dir()
        
        # Telegram Setup
        self.tg_enabled = config.TELEGRAM_ENABLED
        self.tg_token = config.TELEGRAM_BOT_TOKEN
        self.tg_chat_id = config.TELEGRAM_CHAT_ID

    def ensure_log_dir(self):
        """Ensures the directory for the log file exists."""
        if os.path.dirname(self.log_file):
            os.makedirs(os.path.dirname(self.log_file), exist_ok=True)

    def send_telegram(self, message: str):
        """Sends a message to the configured Telegram Chat."""
        if not self.tg_enabled or "YOUR_" in self.tg_token:
            return

        url = f"https://api.telegram.org/bot{self.tg_token}/sendMessage"
        payload = {
            "chat_id": self.tg_chat_id,
            "text": message,
            "parse_mode": "Markdown"
        }
        try:
            # Timeout is important to not hang the bot loop
            response = requests.post(url, json=payload, timeout=5)
            if response.status_code != 200:
                print(f"[AlertEngine] Telegram Error: {response.text}")
        except Exception as e:
            print(f"[AlertEngine] Telegram Connection Failed: {e}")

    def send_alert(self, title: str, message: str, level: str = "INFO", color: str = None):
        """
        Sends an alert/notification.
        
        Args:
            title: Short description or Category (e.g., [SIGNAL], [ERROR])
            message: The content of the alert.
            level: INFO, WARNING, ERROR, CRITICAL.
        """
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Format for Log/Console
        log_msg = f"[{timestamp}] [{level}] {title}: {message}"
        
        # 1. Console Output
        print(log_msg)
        
        # 2. File Log
        self.log_to_file(log_msg)
        
        # 3. Telegram Dispatch
        # We only send specific important events to avoid spamming
        should_send = False
        emoji = ""
        
        if level == "CRITICAL":
            should_send = True
            emoji = "ðŸš¨"
        elif level == "WARNING":
            should_send = True
            emoji = "âš ï¸"
        elif title in ["SIGNAL", "OPPORTUNITY", "EXECUTION"]:
            should_send = True
            emoji = "ðŸš€"
        elif title == "SYSTEM" and "STARTED" in message:
             # Notify when bot starts
             should_send = True
             emoji = "ðŸ¤–"

        if should_send and self.tg_enabled:
            tg_msg = f"{emoji} *{title}*\n{message}"
            self.send_telegram(tg_msg)

    def log_to_file(self, message: str):
        try:
            with open(self.log_file, "a", encoding="utf-8") as f:
                f.write(message + "\n")
        except Exception as e:
            print(f"Error writing to log file: {e}")

    def test_alert(self):
        self.send_alert("TEST", "This is a test alert.", "INFO")


FILE: src/security/authenticator.py
import time
import hmac
import hashlib
import struct

class Authenticator:
    def __init__(self, secret_key: str = "ANTIGRAVITY_SECURE_KEY", interval: int = 15):
        """
        Initialize the Authenticator using a TOTP-like mechanism.
        
        Args:
            secret_key (str): The secret key for HMAC.
            interval (int): Time step in seconds (default 15s).
        """
        self.secret = secret_key
        self.interval = interval

    def generate_code(self, timestamp=None) -> str:
        """
        Generate a 6-digit code based on the current time (or provided timestamp).
        """
        if timestamp is None:
            timestamp = time.time()
        
        # Calculate time counter based on interval
        counter = int(timestamp // self.interval)
        
        # Convert counter to bytes (8 bytes, big-endian)
        counter_bytes = struct.pack(">Q", counter)
        
        # Create HMAC-SHA1 signature using the secret
        key_bytes = self.secret.encode('utf-8')
        hmac_digest = hmac.new(key_bytes, counter_bytes, hashlib.sha1).digest()
        
        # Dynamic Truncation
        offset = hmac_digest[-1] & 0x0F
        binary_code = (
            (hmac_digest[offset] & 0x7F) << 24 |
            (hmac_digest[offset + 1] & 0xFF) << 16 |
            (hmac_digest[offset + 2] & 0xFF) << 8 |
            (hmac_digest[offset + 3] & 0xFF)
        )
        
        # Generate 6-digit OTP
        otp = binary_code % 1_000_000
        return f"{otp:06d}"

    def verify_code(self, code: str, window: int = 1) -> bool:
        """
        Verify the provided code.
        
        Args:
            code (str): The code to verify.
            window (int): Number of intervals to check before/after.
        
        Returns:
            bool: True if valid, False otherwise.
        """
        current_time = time.time()
        
        # Check current, previous, and next windows
        for i in range(-window, window + 1):
            check_time = current_time + (i * self.interval)
            if self.generate_code(check_time) == code:
                return True
        return False

# Self-test if run standalone
if __name__ == "__main__":
    auth = Authenticator()
    code = auth.generate_code()
    print(f"Generated Code: {code}")
    print(f"Verify Result: {auth.verify_code(code)}")


FILE: .github/workflows/stockrobo_bot.yml
name: "StockRobo-US01 Full-Auto Bot"

on:
  schedule:
    # à¸£à¸­à¸šà¸—à¸µà¹ˆ 1: 21:35 à¸™. (14:35 UTC)
    - cron: '35 14 * * 1-5'
    # à¸£à¸­à¸šà¸—à¸µà¹ˆ 2: 23:05 à¸™. (16:05 UTC)
    - cron: '5 16 * * 1-5'
    # à¸£à¸­à¸šà¸—à¸µà¹ˆ 3: 00:35 à¸™. (17:35 UTC)
    - cron: '35 17 * * 1-5'
    # à¸£à¸­à¸šà¸—à¸µà¹ˆ 4: 02:05 à¸™. (19:05 UTC)
    - cron: '5 19 * * 1-5'
    # à¸£à¸­à¸šà¸—à¸µà¹ˆ 5: 03:35 à¸™. (20:35 UTC)
    - cron: '35 20 * * 1-5'
  
  workflow_dispatch: # à¸›à¸¸à¹ˆà¸¡à¸à¸”à¸£à¸±à¸™à¹€à¸­à¸‡

permissions:
  contents: write

jobs:
  trade:
    runs-on: ubuntu-latest
    env:
      PYTHONPATH: .
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: 0. Ensure Data Directory
        run: mkdir -p data

      - name: 1. Scan Market (500+ Stocks)
        run: python generate_combined_watchlist.py

      - name: 2. Execute Trading
        run: python run_phase2_gh_action.py

      - name: 3. Commit and Push Updates
        run: |
          git config --global user.name "StockRobo Full-Auto"
          git config --global user.email "bot@stockrobo.local"
          git add data/portfolio_state.json data/watchlist.json
          git diff --staged --quiet || git commit -m "Full-Auto Update: Portfolio & Watchlist [skip ci]"
          git push origin main || echo "Nothing to push or push failed"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


FILE: PHASE2_SUMMARY.md
# Phase 2: Execution & Automation - Summary

## âœ… Status: COMPLETED

**Completion Date:** 2026-01-27  
**GitHub Actions:** âœ… Successfully Running

---

## ðŸ“ Files Created/Modified

### 1. Core Execution Files
- **`run_phase2_gh_action.py`** - Main script for GitHub Actions execution
  - One-shot execution model (wake â†’ scan â†’ trade â†’ save â†’ sleep)
  - Dynamic path resolution for Linux/Windows compatibility
  - Error handling with detailed logging
  
- **`src/execution/order_manager.py`** - Enhanced with Persistence
  - `load_state()` - Load portfolio from JSON
  - `save_state()` - Save portfolio to JSON
  - Cash balance tracking
  - Order history (last 50 orders)

### 2. GitHub Actions Configuration
- **`.github/workflows/phase2_bot.yml`** - Workflow automation
  - Scheduled runs: 5 times per day (Mon-Fri)
  - Auto-commit portfolio state back to repo
  - Python 3.9 environment setup

### 3. Supporting Files
- **`requirements.txt`** - Python dependencies
  ```
  pandas
  numpy
  yfinance
  schedule
  ```

- **`data/portfolio_state.json`** - Portfolio persistence (auto-created)
  ```json
  {
    "timestamp": <unix_timestamp>,
    "cash_balance": 50000.0,
    "portfolio": {},
    "orders": []
  }
  ```

---

## â° Execution Schedule

**Timezone:** Thailand (GMT+7) â†’ UTC (GMT+0)

| Round | Thailand Time | UTC Time | Market Phase |
|-------|---------------|----------|--------------|
| 1     | 21:35         | 14:35    | Pre-Market   |
| 2     | 23:05         | 16:05    | Market Open  |
| 3     | 00:35         | 17:35    | Mid Session  |
| 4     | 02:05         | 19:05    | Late Session |
| 5     | 03:35         | 20:35    | Near Close   |

**Frequency:** Monday - Friday only  
**Interval:** Every 1.5 hours (90 minutes)

---

## ðŸ”§ Technical Implementation

### Persistence System
```python
# OrderManager automatically saves state after each execution
order_manager = OrderManager(state_file="data/portfolio_state.json")
order_manager.execute_orders(orders)  # Auto-saves after execution
```

### Path Resolution (Cross-Platform)
```python
# Handles both Windows and Linux paths
current_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.append(current_dir)
```

### Error Handling
- Import errors â†’ Detailed file listing for debugging
- Runtime errors â†’ Logged to GitHub Actions console
- Missing state file â†’ Gracefully handled with defaults

---

## ðŸ“Š Resource Usage

**GitHub Actions Free Tier:**
- Limit: 2,000 minutes/month
- Usage: ~200 minutes/month (5 runs/day Ã— 5 days Ã— 4 weeks Ã— 2 min/run)
- Status: âœ… Well within limits

---

## ðŸš€ How to Use

### Manual Trigger
1. Go to GitHub â†’ **Actions** tab
2. Select "StockRobo-US01 Phase 2 Bot"
3. Click **Run workflow** button

### View Results
1. Check **Actions** tab for execution logs
2. View `data/portfolio_state.json` for current portfolio
3. Monitor commit history for auto-updates

### Modify Schedule
Edit `.github/workflows/phase2_bot.yml`:
```yaml
schedule:
  - cron: '35 14 * * 1-5'  # Modify time here
```

---

## ðŸ” Required GitHub Settings

**Repository Settings â†’ Actions â†’ General:**
- âœ… Workflow permissions: **Read and write permissions**
- âœ… Allow GitHub Actions to create pull requests: **Enabled**

---

## ðŸŽ¯ Key Features Implemented

1. **Stateless Execution** - Bot remembers portfolio between runs
2. **Automatic Scheduling** - Runs without manual intervention
3. **Cloud-Based** - No need to keep computer running
4. **Error Recovery** - Graceful handling of edge cases
5. **Audit Trail** - All trades logged and committed to repo

---

## ðŸ“ Next Steps (Phase 3)

- [ ] Dashboard for visualization
- [ ] Line/Telegram notifications
- [ ] Real broker integration (Alpaca/IB)
- [ ] Advanced risk management
- [ ] Performance analytics

---

## ðŸ› Troubleshooting

### Bot not running?
- Check **Settings â†’ Actions** permissions
- Verify workflow file syntax
- Check GitHub Actions quota

### Import errors?
- Ensure `src/` folder is uploaded to GitHub
- Check `run_phase2_gh_action.py` path resolution

### State not saving?
- Verify write permissions in workflow
- Check `data/` folder exists
- Review commit logs in Actions

---

**Status:** âœ… Production Ready  
**Last Updated:** 2026-01-27  
**Version:** 1.0.0



